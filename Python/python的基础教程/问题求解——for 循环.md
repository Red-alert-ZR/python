'''
##### 几何图形是从现实世界抽象出的各种图形，如矩形、三角形、圆形等，可以用来刻画错综复杂的世界。在 Python 中，除了用绘图库绘制外，也可以利用print函数打印几何图形，而本关任务是打印一个高度为 n 的等腰三角形，如 n=4 时，打印结果如下：  

   *     
  ***    
 *****   
*******  
例题
　　若用print打印一个边长为 n 的正方形，代码如下：  

n = 4  
for i in range(n):  
    print('*' * n)  
　　最后一行将字符串与整数n相乘，表示将这个字符串重复拼接 n 次，如'*' * 4是****、'abc'*3是abcabcabc。此外，字符串与字符串可以相加，其作用也是拼接，如'abc'+'def'的结果是'abcdef'。  
　　因显示原因，上面的程序打印出来的结果看起来并不像正方形，可以将最后一行的'*' * n改为'*  ' * n，即在第 1 个星号后面添加两个空格（本关过关程序中不用这么做）。

特殊字符
　　在字符串里面，有时会出现一些以\开头的特殊字符（称为转义符），如\n表示换行符（类似回车键的效果）、\t表示制表符（比空格更宽且宽度可变的一段空白）。尝试如下程序，观察这些特殊符号的显示效果。  

print('a\nb')   #a和b分两行显示，因为它们中间有一个换行符\n  
print('ccc\td') #ccc和d之间有一段较长的空白，即为制表符\t  
print('e\tf')   #f与上行的d对齐，形成表格效果，这也是“制表”的由来  
　　可上网查询 Python 中的其他转义符。

print 的行尾符
　　行尾符是print在打印内容尾部添加的字符串。默认情况下，print的行尾符是换行符\n，所以每次使用print都会从新的一行开始打印，例如下面的程序两次使用print，打印出来的就是两行：  

print('a') #打印a，在a后面添加\n  
print('b') #打印b，在b后面添加\n  
　　也可以手动设置print的行尾符，如下面的程序打印结果只有一行（a-b-）：  

print('a', end='-') #将行尾符设置为-，打印a后，在后面添加-  
print('b', end='-') #将行尾符设置为-，打印b后，在后面添加-  
　　如果想把若干个print的打印内容首尾拼接成一行，可以将行尾符设置成空字符串''（两个连续的引号），即包含 0 个字符的字符串，表示行尾什么都不加。比如，要打印“3 个减号、1 个星号、3 个减号”，程序可以是：  

print('-'*3, end='') #打印3个减号  
print('*', end='')   #打印1个星号  
print('-'*3)         #打印3个减号，然后添加\n  
　　本关就可以采用这种方式打印三角形的每一行。

print 的分隔符
　　除行尾符外，print里面还有分隔符的概念，即print用来分隔多个打印对象所用的字符串。默认情况下，print使用空格作为分隔符，例如下面的程序打印结果为a b c，三个字符之间以空格分隔。  

print('a','b','c') #依次打印a、b、c，并在它们之间加上空格  
　　也可以手动设置print的分隔符，如下面的程序打印结果是a+b+c。  

print('a','b','c', sep='+') #将分隔符设置为+  

##  1  ##
'''

        n = int(input())  
        ########## Begin ##########  
        for i in range (1, n+1):  
            print(" "*(n-i),end='')  
            print("*"*(i*2-1),end='')  
            print(" "*(n-i))  
        ########## End ########## 

'''
#####  从物理学的角度看，煮鸡蛋并不是一件简单的事。##### 设煮鸡蛋的理想水温为 T 
##### （取 65℃），则煮鸡蛋的时长 t（秒）计算公式如下：


 ![image (1)](https://user-images.githubusercontent.com/99107924/160576758-acb7eb81-3d29-4614-9781-91437f367450.png)

  
 ##### 则原式变为：  
 
 ![image (2)](https://user-images.githubusercontent.com/99107924/160577063-880af005-0d78-49c6-9002-2d8642d52720.png)


程序运行结果为：  

-10    500  
-5    480  
0    459  
5    436  
10    413  
15    388  
20    361  
25    333  
30    303  
35    270  
##  2  ##
'''

      ########## Begin ##########
      import math
      for i in range(-10, 40, 5):
          t = 437.3*math.log((100-i)/35)
          print(i,end='\t')
          print(int(t))
          i = i + 5
      ########## End ##########

'''
##### 　自然常数 e 是一个无限不循环小数， e=2.71828182845904…。虽然自然常数的知名度不如圆周率，且在生活中用得不是很多，但它和圆周率一样，也是数学中最重要的一个常数。例如，自然对数 ln 就是以自然常数为底数的对数，欧拉公式 pow(e,iπ)+1=0 被称为“最完美的数学公式”，就是因为它包含了自然常数在内的5个最重要的数学元素。
##### 自然常数的历史不如圆周率久远，最早出现在约翰·纳皮尔于 1618 出版的一本著作中，1690 年在莱布尼茨与惠更斯的通信中第一次被使用，1727 年欧拉开始用符号 e 表示这个常数，随后逐渐流传开来。
##### 关于为什么用符号 e 表示自然常数，并无定论。有人认为这是取欧拉名字（Euler）的首字母，也有人认为是“指数”一词（exponential）的首字母，还有人认为这是因为 a、b、c、d 经常被使用，而 e 是第 1 个比较合适的字母。
#### 任务
##### 自然常数的近似值可用下式求得，其中 ! 表示阶乘：  
![image (3)](https://user-images.githubusercontent.com/99107924/160579439-6d93c641-3636-4970-bf8b-327614ae2994.png)


##### 本关任务是利用上式计算自然常数近似值。  

##  3  ##
'''

    import math
    n = int(input())
    ########## Begin ##########
    e = 1
    for i in range(1,n+1):
        e = 1/math.factorial(i)+e
    ########## End ##########
    print('%.14f' % e) #×ÔÈ»³£Êý=2.71828182845904...


'''
##### 　　泰勒级数是“高等数学”中的一个重要内容，利用泰勒级数，可以将一些函数展开为多项式，例如，正弦函数 y=sin⁡(x) 经泰勒级数展开可得：  

![image (4)](https://user-images.githubusercontent.com/99107924/160599442-f6d13293-d4f2-4458-b715-1c955fb521cb.png)

##### 很多其他函数也可以类似展开。但这有什么用？其实泰勒级数应用非常广泛，是科学和工程中的一个有力工具。例如，之前关卡计算圆周率、自然常数所用公式，其实就是应用泰勒级数得到的，泰勒级数给出了计算这些常数的对应方法。
##### 又例如，在“问题求解——while 循环”实训中提到，计算机底层只能进行加、减、乘、除等一些最基本的运算，三角函数等更复杂的运算需要转换成这些基本运算才能进行，而泰勒级数就是“复杂运算”向“基本运算”转换的一种有效方法。
　　
#### 本关任务是利用正弦函数的泰勒展开式求正弦值。


##  4  ##
'''

          import math
          n = int(input())
          x = eval(input())   #输入时采用度数，如30表示30°
          x = math.radians(x) #将度转换为弧度，如30°转换为π/6，泰勒展开式中的x要使用弧度
          ########## Begin ##########
          y = 0
          if n >= 0 :
              for i in range(0,n+1):
                  y = (pow(-1,i)*pow(x,2*i+1))/(math.factorial(2*i+1))+y
              print('%.8f' % y)
          else:
              print('输入错误')
          ########## End ##########


'''
##### 完全数又称完备数、完美数，它是这样一种自然数，其所有真因子（除自身外的约数）之和等于本身。例如， 6 是完全数，因为它的真因子 1、2、3 之和等于 6；而 16 不是完全数，因为它的真因子 1、2、4、8 之和等于 15。

##  5  ##
'''

          n = int(input())
          ########## Begin ##########
          a = 0
          i = 1
          while i < n :
              if n%i == 0:
                  a = a+i
                  if a == n:
                      break
                  else:
                      i = i+1
              else:
                  i =i+1
          if a == n:
              print('True')
          else:
              print('False')
          ########## End ##########

'''
###### 　上一关是判断给定的数是否为完全数，而本关任务是寻找 1000 以内所有的完全数。

#### 嵌套循环
　　本关可能要用到嵌套循环，也就是循环中又包含循环。此处先结合本关需要给出一个示例，在“绘制炸弹轨迹 V”实训最后一关还将进一步介绍。
　　例如，如下程序是计算从 1 到 n 之和：  

n = 10  
s = 0  
for i in range(1,n+1):  
    s = s+i  
print(s)  
　　如果要依次计算 1 到 10、1 到 11、1 到 12、……、1 到 19 之和，则程序如下：  

for n in range(10, 20):  
    s = 0  
    for i in range(1,n+1):  
        s = s+i  
    print(s)  
　　这其实就是一个两层嵌套的 for 循环。for n in range(10, 20)是外层循环，n从10变到19，每循环一次，计算和打印某个 n 对应的情况（下图左边部分）。而在计算1到某个 n 之和时，又要用到了循环for i in range(1,n+1)（下图右边部分），这是内层循环。  
  
![image (5)](https://user-images.githubusercontent.com/99107924/160606681-230c2507-270c-4516-a5e0-7068c6362b85.png)


##  6  ##
'''

            ########## Begin ##########
            for i in range(1,1000):
                s = 0
                j = 1
                while j < i :
                    if i%j == 0:
                        s = s+j
                        j = j+1
                        continue
                    else:
                        j =j +1
                        continue
                if s == i:
                    print(i)
            ########## End ##########


'''
###### 与完全数相比，素数是一种更被人所熟知的数字。
　　素数也叫质数，它是不包含 1 的正整数，除了 1 和本身以外没有其他约数。例如，7 是素数，因为它的约数只有 1 和 7，不存在 1 和本身之外的其他约数；9 不是约数，因为它的约数是 1、3、9，除了 1 和本身之外，约数还有 3。
　　素数是数论中的一个核心概念，同时也是数论中为数不多的得以实际应用的内容。例如，要计算两个很大的素数之积是一件很容易的事，但反过来，要将这个很大的数分解成两个素数，则非常困难，即使是计算机也难以在有效时间内完成，这种性质成为了密码学的一个基础。
　　但是，关于素数，还存在着太多的未解难题，等待着人们的进一步研究。例如，作为世界三大数学猜想之一的哥德巴赫猜想，一种表述方式为“任一大于 2 的偶数都可以写成两个素数之和”，这样一个浅显易懂的题目，提出至今 200 余年，仍未得到解决，成为三大猜想中剩下的唯一一个未解之题。又例如，世界七大数学难题中的黎曼猜想，是当今数学界最重要的难题之一，它预测了素数的分布规律，但这种预测是对还是错，即使在百万美金悬赏下，至今也无人能回答。

任务
　　本关任务是判断一个大于 1 的正整数 n 是不是素数。

相关知识
　　提示：本关任务可能没你想的那么简单。到底怎样的 n 才是素数？它应该是 2 到 n−1 都不能整除的数，只要其中有一个能整除，那它就不是素数。
　　所以，可以先假设 n 是素数，然后依次尝试 2 到 n−1：如果在尝试过程中出现整除 n 的情况，则推翻假设，n 不是素数；若尝试完 2 到 n−1 中所有数，都没出现整除现象，则假设成立，n 是素数。
　　可以先分别选一个素数和一个非素数，比如 7 和 9，试一下上面的判断方法，然后提炼出具体的算法，再编程实现。


##  7  ##
'''

            n = int(input())
            ########## Begin ##########
            a = 0
            for i in range(2,n):
                while i < n:
                    if n%i == 0:
                        a = 1
                        break
                    else:
                        i = i+1
                        continue
            if a == 0:
                print('True')
            elif a == 1:
                print('False')
            ########## End ##########


'''
###### 数学的计算结果通常是精确的。例如，用积分计算下图阴影部分面积，得 ![image (7)](https://user-images.githubusercontent.com/99107924/160610842-ca8a8418-5059-432e-b77f-0521f20c13c3.png) ###### 我们把这种用解析表达式表示的精确计算结果称为解析解。  
###### 而计算机往往是采用数值方法计算近似结果。例如，用后面介绍的细分法计算上图阴影部分面积，得 S=12.0703，与解析解很相近，但不是精确相等。我们把这种用数值方法得到的近似计算结果称为数值解。
###### 虽然数值解很多时候是近似值，但它却有着非常广泛的应用。一方面，很多时候并不要求结果百分之百准确，只要足够准确就够了，如计算建筑面积，多一平方微米或少一平方微米，并无太大关系；另一方面，有些时候要算出解析解非常困难，甚至不可能，这时候只能使用数值解。

　　1）如上图，将 [0,π] 区间平均分为 4 个子区间；
　　2）在每个子区间中，将曲线近似看做一条线段，即可形成一个梯形（三角形可以看做特殊的梯形），用梯形面积近似代替子区间的实际面积；
　　3）将 4 个子区间对应的梯形面积相加。
　　本关任务就是计算 n 为不同值时细分法求得的阴影面积。

相关知识
　　参考之前关卡。
![image (6)](https://user-images.githubusercontent.com/99107924/160608954-b493cf9c-3e9a-4afe-95d1-431e11a385ff.png)

##  8  ##
'''


          import math
          n = int(input())
          ########## Begin ##########
          h = math.pi/n
          S = 0
          for i in range(1,n+1):
              x1 = (i-1)*h
              x2 = i*h
              y1 = (math.e**x1)*math.sin(x1)
              y2 = (math.e**x2)*math.sin(x2)
              S = ((y1)+(y2))*h*(1/2)+S
          ########## End ##########
          print('%.4f' % S) #解析解=12.0703...
          
   
##  9 求解区间范围内的素数 ##


        #for
        import math
        M=eval(input())
        N=eval(input())

        #   请在此补全代码   #
        # ********** Begin *********#
        for m in range(M,N+1):
            t = int(math.sqrt(m))
            i = 2
            while i <= t:
                if m%i == 0:
                    break
                i = i+1
            else:
                print(m)

        # ********** End **********#

### 这个应该是最简单的了

          
          
